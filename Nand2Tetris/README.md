# Nand2Tetris
このリポジトリは「[コンピュータシステムの理論と実装](https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E7%90%86%E8%AB%96%E3%81%A8%E5%AE%9F%E8%A3%85-%E2%80%95%E3%83%A2%E3%83%80%E3%83%B3%E3%81%AA%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%81%AE%E4%BD%9C%E3%82%8A%E6%96%B9-Noam-Nisan/dp/4873117127)」という本を進めたときのログです。  
[この本の参考サイト](https://www.nand2tetris.org/)

## きっかけ
業務外でスキルアップを図るため  
業務内で触れることが増えてきたlinuxのソースコードを読んでみようと思ったが  
そもそもの前提知識の不足で途方に暮れてしまったので  
低レイヤから順に進めていくこちらの本で土台を固めてから  
再度挑戦してみようと思ったので。

## 進める上で参考になった本、サイトなど
- [Linuxカーネルを読む前にやったこと](http://komukomo.hatenablog.com/entry/2017/04/25/023455)
- [低レイヤーの学び方](https://geek-out.jp/column/entry/2018/07/19/110000/)
- [低レイヤーの歩き方](http://rkx1209.hatenablog.com/entry/2016/12/25/141543)
- [「コンピュータシステムの理論と実装」をやりきりました](https://qiita.com/y-meguro/items/dc11c31cc2667aa20b3c)
- [Linux for Hackersシリーズ](https://nanashi0x.hatenablog.com/entry/2017/12/17/201714)
- [コンピュータの基礎知識](https://ufcpp.net/study/computer/)

## 全体の流れ
1章
論理ゲート  
2〜3章
「順序回路」と「組み合わせ回路」  
4〜5章
コンピュータアーキテクチャ  
=====ハードウェアとソフトウェアの垣根=====  
6〜8章
ソフトウェア階層  
9章
オブジェクトベースの言語  
10〜11章
9章で作成した言語のコンパイラ作成  
12章
OSの設計・実装

## 読書メモ
### 1章(ブール論理)
- NANDの作成について
### 2章(ブール算術)
- 加算器とALU(算術論理演算器)の実装
### 3章(順序回路)
- 1章と2章で作成した回路は組み合わせ回路で入力によって決定する。状態は保持できない。
- フリップフロップと呼ばれる順序回路で解決
- コンピュータで状態を保つために用いられるハードウェア装置(2値素子、レジスタ、RAM)はフリップフロップという回路で形成される
- レジスタとはデータを「格納」、「呼び出し」することができる記憶装置
- 多ビットのレジスタは1ビットレジスタを必要な数だけそろえて、それらを配列上に並べて構築できる。ここで保持すべきビットの数を幅(Width)からとって、ワード(word)ビットレジスタ(wビットレジスタ)
- メモリのRAM(ランダムアクセスメモリ)の名前の由来はランダムに選ばれたワードに対して制限を受けることなく、書き込み/読み込みができる、ということから来ている
### 4章(機械語)
- コンピュータを構造的な視点で説明するなら、ハードウェアのプラットフォームを提示し、それが下位レベルの回路からどのように構築されているか説明
- コンピュータを抽象的な視点で説明するなら、機械語の仕様を提示し、それによって何ができるかを明らかにすれば良い
- 新しいコンピュータシステムに慣れ親しむなら、機械語で書かれた低水準言語のプログラムを見るのが手っ取り早い
- コンピュータにおいて最も重要なインターフェイスは機械語
- バイナリコード(0,1) + ニーモニック(記号や英単語) = 機械語
- 機械語による抽象化を推し進めるとアセンブリ言語
- アセンブリ言語から機械語に変換することをアセンブラ
### 5章(コンピュータアーキテクチャ)
- コンピュータは制限のあるハードウェアを備えたマシンではあるが、プログラム内蔵方式と呼ばれるもので柔軟性が実現されている
- 一般的にコンピュータとはノイマン型コンピュータを指す
- ノイマン型コンピュータはCPUを中心として、メモリデバイスを操作し、入力デバイスからデータを受け取って、出力デバイスへデータを送信する
- I/Oデバイス(入出力装置)はメモリマップドI/Oという技法を用いることで、どんなPC、OSで関係なく同じ動作をする
- メモリマップドI/Oとは、あらかじめメモリに領域を確保して、入力されたらそのメモリをロードする。という内容
### 6章(アセンブラ)
- 機械語は「シンボル」と「バイナリ」の２つの方法で指定される
- アセンブリ言語は「LOAD R3, 7」という記号を用いた表記
- シンボルはプログラミングにおける変数
- 高水準言語のコード中にアセンブリ言語を埋め込むことができる。これによりハードウェアを直接制御できる
### 7章(バーチャルマシン#1: スタック操作)
- 高水準プログラムは中間コードに変換され機械語に変換される
- VM(バーチャルマシン)実装を構築する作業は、２つのタスクから構成される。１つは対象のプラットフォーム上でVMの世界をシミュレートする。２つめは各VMコマンドを一連の命令に変換する。
### 8章(バーチャルマシン#1: プログラム制御)
-
### 9章(高水準言語)
- 低水準(人が直接読み書きすることを想定していない)
- 高水準(プログラマーが読み書きする)
- サブルーチン呼び出し(メソッド、関数、コンストラクタ)
### 10章(コンパイラ#1: 構文解析)
- ソース言語で書かれたプログラムを目的の言語で書かれたプログラムへ変換するプロセスのことをコンパイル
- 変換プロセスは概念的に２つの作業に基づく、一つは構文解析、二つはコード生成
- 構文解析はさらに２つの作業に分割できる、トークナイザ(意味を持つコードの最小単位トークン(字句)に変換)とパーサ(トークンを言語の構文ルールに適用させ、構文構造を明らかにする)
### 11章(コンパイラ#2: コード生成)
- プログラムは本質的には、データを操作する一連の命令。高水準から低水準言語へのコンパイル作業は、２つの変換(データ変換、コマンド変換)
### 12章(オペレーティングシステム)
- デバイスのインターフェイスの詳細をカプセル化し、その装置にアクセスするための便利な関数群->デバイスドライバ
